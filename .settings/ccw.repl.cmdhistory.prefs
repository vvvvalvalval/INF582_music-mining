cmdhistory=["(clojure.core/use 'clojure.core)" "(import 'org.herac.tuxguitar.io.tg)" "(def settings (GTPSettings.))" "(class settings)" "(.getCharset settings)" "(. settings getCharset)" "(doc clojure.java.io/resource)" "(clojure.core/use 'clojure.core)" "(doc clojure.java.io/resource)" "(use 'clojure.repl)" "(doc clojure.java.io/resource)" "(use 'clojure.java.io/resource)" "(require '[clojure.java.io \:only resource])" "(resource \\"hello.txt\\")" "(require '[clojure.java.io \:as cio])" "(cio/resource \\"sample-file.txt\\")" "(def my-file-url (cio/resource \\"sample-file.txt\\"))" "my-file-url" "(def my-stream (java.io.FileInputStream. my-file-url))" "(def my-stream (. my-file-url openStream))" "(class my-stream)" "(. my-stream read)" "(. my-stream close)" "(defn open-my-stream [] (. my-file-url openStream))" "(def my-reader (BufferedReader. (InputStreamReader. (open-my-stream))))" "(class my-reader)" "(. my-reader readLine)" "(. my-reader close)" "(def my-tg-factory (TGFactory.))" "(. my-tg-factory newBeat)" "(def my-beat (. my-tg-factory newBeat))" "(class my-beat)" "(. my-stream close)" "(defn mygp3 []\\n  (resource-as-stream \\"sample-gp3.gp3\\"))" "(def myGP3stream (mygp3))" "(def gp3-is (GP3InputStream. settings))" "(class gp3-is)" "(. gp3-is (init my-tg-factory myGP3stream))" "(. gp3-is readSong)" "(. *1 getName)" "(. myGP3stream close)" "GP1InputStream." "GP4InputStream." "GP1InputStream" "(class GP1InputStream.)" "(class GP1InputStream)" "(def myclass java.util.HashMap)" "(myclass.)" "(def hm (new myclass))" "(GP1InputStream/GP1InputStream)" "(use 'clojure.tools.nrepl)" "(use 'clojure.repl)" "(doc new)" "(def my-class HashMap)" "(def my-class Object)" "(new myclass)" "(doc new)" "(new \\"Object\\")" "(new \\"java.lang.Object\\")" "(doc apply)" "(apply String '(\\"hello\\"))" "(doc with-open)" "(doc doto)" "(read-song\\n  (resource-as-stream \\"sample-gp3.gp3\\")\\n  \:gp3)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "(doc doto)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "*1" "(def my-song *2)" "my-song" "(def my-song (read-song\\n        (resource-as-stream \\"sample-gp3.gp3\\")\\n        \:gp3))" "my-song" "(. my-song toString)" "(. my-song getArtist)" "(. my-song getDate)" "(. my-song getMeasureHeaders)" "my-song" "(count (. my-song getMeasureHeaders))" "(doc read-song)" "(println \\"Hello\\")" "(doc extend-type)" "(doc deftype)" "(doc extend)" "(in-ns 'music-mining.tg-factory)" "(def song (Song.))" "(class song)" "song" "(doc proxy)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n           \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n              \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                 \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                    \:gp3)" "(time (dotimes [n 100]\\n        (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                             \:gp3)))" "(time (dotimes [n 1000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(time (dotimes [n 10000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(read-song \\n  (resource-as-stream \\"rhapsody.gp4\\") \:gp4)" "(time (dotimes [n 1000] (read-song \\n                             (resource-as-stream \\"rhapsody.gp4\\") \:gp4)))" "(def rhapsody \\n  (read-song (resource-as-stream \\"rhapsody.gp4\\") \:gp4))" "(.getName rhapsody)" "chello" "au-clair-de-la-lune" "(. getTracks au-clair-de-la-lune)" "(.getTracks au-clair-de-la-lune)" "(println (.getTracks au-clair-de-la-lune))" "au-clair-de-la-lune" "(print *e)" "au-clair-de-la-lune" "chello" "au-clair-de-la-lune" "chello" "rhapsody" "chello" "au-clair-de-la-lune" "drums" "several-instruments" "(def ptrack\\n  (.. drums getTracks next))" "(class ptrack)" "(percussion-track? ptrack)" "(def atrack\\n     (.. chello getTracks next))" "(percussion-track? atrack)" "(defn ^TGTrack first-track [^TGSong song]\\n  (.. song getTracks next))" "(percussion-track? (first-track au-clair-de-la-lune))" "(percussion-track? (first-track several-instruments))" "(percussion-track? (first-track rhapsody))" "au-clair-de-la-lune" "(doc iterator-seq)" "(- 3)" "(chello)" "chello" "(doc doseq)" "0/1" "1/2" "(class 0/1)" "(class 1/2)" "(+ 1/2 0)" "(.iterator [1 2 3 4])" "(iterator-seq (.iterator [1 2 3 4]))" "(doc swap\!)" "(doc doseq)" "au-clair-de-la-lune" "two-voices" "(doc conj)" "au-clair-de-la-lune" "(def atrack (. au-clair-de-la-lune (getTrack 0)))" "atrack" "(notes-of-track atrack)" "(def another-track (. chello (getTrack 0)))" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(doc defrecord)" "(doc vec)" "(notes-of-track atrack)" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(notes-of-song chello)" "(notes-of-song rhapsody)" "(notes-of-song au-clair-de-la-lune)" "(clojure.core/use 'clojure.repl)" "(find-doc pretty-print)" "(find-doc \\"pretty print\\")" "(notes-of-song several-instruments)" "(clojure.pprint \\"hello\\")" "(use 'clojure.pprint)" "(pprint (notes-of-song au-clair-de-la-lune))" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(pprint-song drums)" "(doc not)" "(notes-of-song drums)" "(pprint-song several-instruments)" "(pprint-song chello)" "(count (iterator-seq (. chello getTracks)))" "(pprint-song rhapsody)" "(time (let \\n        [res (notes-of-song rhapsody)]\\n        nil))" "(class 1/6)" "(pprint-song au-clair-de-la-lune)" "(pprint chello)" "(pprint-song chello)" "(doc comp)" "(pprint-song rhapsody)" "(doc pprint)" "*out*" "(class *out*)" "(source doc)" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(pprint-song chello)" "(pprint-song rhapsody)" "bend" "(def track (.. bend getTracks next))" "track" "(def measure (.. track getMeasures next))" "measure" "(def note (.. measure (getBeats 0) (getVoice 0) (getNotes 0)))" "(def note (.. measure (getBeats) (get 0) (getVoice 0) (getNotes) (get 0)))" "note" "(def effect (. note getEffect))" "effect" "(def bend-effect (. effect getBend))" "bend-effect" "(. bend-effect getPoints)" "(. (last (. bend-effect getPoints)) getValue)" "(. (first (. bend-effect getPoints)) getValue)" "(. ((. bend-effect getPoints) 1) getValue)" "(doc nth)" "(. (nth (. bend-effect getPoints) 1) getValue)" "(. (nth (. bend-effect getPoints) 0) getValue)" "(if nil true false)" "(pprint-song au-clair-de-la-lune)" "(doc spit)" "(pprint-song smoke-water)" "smoke-water" "(pprint-song smoke-water)" "(pprint-song au-clair-de-la-lune)" "(pprint-song bend)" "(pprint-song au-clair-de-la-lune)" "(au-clair-de-la-lune)" "au-clair-de-la-lune" "(pprint-song au-clair-de-la-lune)" "(doc or)" "(or nil 3)" "(or 5 nil)" "(or 2 3)" "(pprint-song au-clair-de-la-lune)" "(pprint-song bend)" "bend" "(pprint-song bend)" "(find-doc floor)" "(find-doc \\"floor\\")" "(doc int)" "(doc %)" "(pprint-song au-clair-de-la-lune)" "(int 2/3)" "(int 7/4)" "(doc quot)" "(quot 7 5)" "(pprint-song bend)" "(pprint-song rhapsody)" "(pprint-song au-clair-de-la-lune)" "(doseq pprint-song all-samples)" "(map pprint-song all-samples)" "(doc map)" "(pprint-song chello)" "(pprint-song rhapsody)" "(pprint-song au-clair-de-la-lune)" "(pprint-song drums)" "(pprint-song several-instruments)" "(pprint-song two-voices)" "(pprint-song smoke-water)" "*e" "(. *e getTrace)" "(. *e printStackTrace)" "(. *e getStackTrace)" "smoke-water" "(pprint smoke-water)" "(pprint-song smoke-water)" "(notes-of-song smoke-water)" "(quot 255 4)" "(notes-of-track (.. smoke-water (getTracks) (next)))" "(notes-of-track (.. smoke-water (getTracks) (next) (next)))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0)))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 1))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 2))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 3))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 1)))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0)))" "(quot 3 4)" "(quot 255 4)" "(rem 255 4)" "(doc let)" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(quot 815/2 4)" "(rem 815/2 8)" "(rem 815/2 4)" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(quot 512/2 4)" "(alert-null 3 \\"should not show\\")" "(alert nil \\"should show\\")" "(alert-null nil \\"should show\\")" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(notes-of-track (nth (. smoke-water getTracks) 0))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(def track (nth (iterator-seq (. smoke-water getTracks)) 0))" "track" "(def measure (nth (. track getMeasures) 64))" "(def measure (nth (iterator-seq (. track getMeasures)) 64))" "measure" "(def beat (nth (. measure getBeats) 4))" "beat" "(def note (.. beat (getVoice 0) (getNote 0)))" "note" "(. note getEffect)" "(.. note getEffect getBend)" "(.. note getEffect getTremoloBar)" "(.. note getEffect getTremoloBar getPoints)" "(.. note getEffect getTremoloBar getPoints (get 2))" " (.. note getEffect getTremoloBar getPoints (get 2) getValue)" "(quot 512/2 4)" "(rem 512/2 4)" "(rem 515/2 4)" "note" "(def tg-string (.. track (getString 3)))" "tg-string" "(pitch-of-fretted-note tg-string note)" "(pprint-song smoke-water)" "(pprint-song rhapsody)" "(pprint-song au-clair-de-la-lune)" "(pprint-song bend)" "au-clair-de-la-lune" "(notes-of-song au-clair-de-la-lune)" "(pprint-song au-clair-de-la-lune)" "(doc clojure.java.io)" "all-songs-directory" "(. all-songs-directory isDirectory)" "(seq (. all-songs-directory listFiles))" "all-songs-directory" "(seq (. all-songs-directory listFiles))" "(doc lazy-seq)" "(doc cio/input-stream)" "(doc cio/file)" "(file all-songs-directory)" "(cio/file all-songs-directory)" "(doc mapcat)" "(def some-file (cio/file all-songs-directory \\"Q\\" \\"Queen\\" \\"Bicycle Race.gp3\\"))" "(FilenameUtils/getExtension (. some-file getName))" "(def extension\\n      {\\"gp1\\" \:gp1,\\n       \\"gp2\\" \:gp2,\\n       \\"gp3\\" \:gp3,\\n       \\"gp4\\" \:gp4,\\n       \\"gp5\\" \:gp5\\n       })" "(extension \\"gp1\\")" "(extension \\"bite\\")" "(doc cond)" "(doc cio/input-stream)" "(songs-in-directory all-songs-directory)" "(doc if-not)" "(songs-in-directory all-songs-directory)" "(take 10 (songs-in-directory all-songs-directory))" "(take 2 (songs-in-directory all-songs-directory))" "(class (cio/file \\"hello.txt\\"))" "(take 2 (songs-in-directory all-songs-directory))" "(pprint (take 2 (songs-in-directory all-songs-directory)))" "(doc fn)" "all-songs-files" "(map all-songs-files pprint)" "(map pprint all-songs-files)" "(doc doseq)" "(count all-songs-files)" "(doseq [sf all-songs-files]\\n  (pprint sf))" "(doc doall)" "(time (do\\n        (doall all-songs-files)\\n        (count all-songs-files)))" "(to-nice-song\\n  (first all-songs-files))" "(to-nice-song\\n     (first all-songs-files))" "(pprint (to-nice-song\\n     (first all-songs-files)))" "(do doseq)" "(doc doseq)" "(time\\n  (doseq [songfile all-songs-files]\\n  (try\\n    (to-nice-song songfile)\\n    (catch java.lang.Exception e\\n      (println \\"Problem with song \\" songfile \\" \: \\" e)))) \\n)" "(time (parse-all-songs))" "(count (deref songfiles-with-problems))" "(map \#(.printStackTrace %)\\n     (vals (deref songfiles-with-problems)))" "(time (parse-all-songs))" "(/ 11008001.124425 60000)" "(/ 1100801.124425 60000)" "(vals songfiles-with-problems)" "@songfiles-with-problems" "(pprint all-songs-files)" "(parse-all-songs)" "(pprint @songfiles-with-problems)" "(doc let)" "(time (development-songs-files))" "(time (parse-all-songs))" "(count development-songs-files)" "(time parse-all-songs)" "(time (parse-all-songs))" "@songfiles-with-problems" "(pprint @songfiles-with-problems)" "(count @songfiles-with-problems)" "(time\\n  (doseq [{file \:file,\\n           fmt \:format} development-songs-files]\\n    (try\\n      (read-song (cio/input-stream file) fmt)\\n      (catch Exception e\\n        nil))))" "(time\\n     (doseq [{file \:file,\\n              fmt \:format} (take 500 (shuffle development-songs-files))]\\n       (try\\n         (read-song (cio/input-stream file) fmt)\\n         (catch Exception e\\n           nil))))" "(time\\n        (doseq [{file \:file,\\n                 fmt \:format} (take 500 (shuffle development-songs-files))]\\n          (try\\n            (read-song (cio/input-stream file) fmt)\\n            (catch Exception e\\n              nil))))" "(file-seq development-songs-directory)" "(pprint (file-seq development-songs-files))" "(pprint (file-seq development-songs-directory))" "(pprint\\n  (file-seq all-songs-directory))" "(doc ->>)" "(doc try)" "(try 4)" "(doc apply)" "(take-sparsely 4 (list 1 2 3 4 5 6 7 8 9 10 11))" "(take-sparsely 4 (list 1 2 3 4 5 6 7 8 9 10 11 12))" "(take-sparsely 4 (list 1 2 3 4 5 6 7 8 9 10 11 12 13))" "(take-sparsely 4 (range 1 11))" "(rem 11 4)" "(take-sparsely 4 (range 1 11))" "(take-sparsely 4 (range 1 16))" "(take-sparsely 4 (range 1 523))" "(take 3 all-tg-songs)" "(doc file-seq)" "(seq? (file-seq all-songs-directory))" "(gp-files-seq all-songs-directory)" "(pprint (gp-files-seq all-songs-directory))" "(take-sparsely 500 all-tg-songs)" "(take-sparsely 5 all-tg-songs)" "(take 5 all-tg-songs)" "(pprint\\n  (take 5 all-tg-songs))" "(map \#(.getName %) a-few-tg-songs)" "(pprint (map \#(.getName %) a-few-tg-songs))" "(take 5 (map \#(\:file %) a-few-tg-songs))" "(take 5 (map \#(% \:file) a-few-tg-songs))" "(take 5 (map \#(\:file %) a-few-tg-songs))" "(pprint\\n  (take 2 a-few-tg-songs))" "(pprint (take 2 a-few-tg-songs))" "(pprint (take 5 all-tg-songs))" "(take 2 all-tg-songs)" "(pprint-song au-clair-de-la-lune)" "(println \\"hello\\")" "(time (println \\"hello\\"))" "(println \\"hello\\")" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(doc file-seq)" "(time\\n  (do \\n    (file-seq all-songs-directory)\\n    nil))" "(time\\n     (do \\n       (doall (file-seq all-songs-directory))\\n       nil))" "(take 10 (gp-files-seq all-songs-directory))" "(take-sparsely 10 (gp-files-seq all-songs-directory))" "(pprint (take-sparsely 10 (file-and-formats-seq (gp-files-seq all-songs-directory))))" "(pprint (take-sparsely 10 (tg-songs-seq (gp-files-seq all-songs-directory))))" "(pprint (tg-songs-seq (take-sparsely 10 (gp-files-seq all-songs-directory))))" "(gp-files-seq (cio/file \\"/home/val/Bureau/Cours\\" \\"INF Datamining\\" \\"projet_music\\" \\"music-mining\\" \\"resources\\"))" "(tg-songs-seq (gp-files-seq (cio/file \\"/home/val/Bureau/Cours\\" \\"INF Datamining\\" \\"projet_music\\" \\"music-mining\\" \\"resources\\")))" "(pprint\\n  (tg-songs-seq (gp-files-seq (cio/file \\"/home/val/Bureau/Cours\\" \\"INF Datamining\\" \\"projet_music\\" \\"music-mining\\" \\"resources\\"))))" "a-few-tg-songs" "(time\\n  (do\\n    (doall (tg-songs-seq (take-sparsely 10 (gp-files-seq development-songs-directory)))))\\n  nil)" "(println \\"hello\\")" "(time\\n  (do\\n    (doall a-few-tg-songs)\\n    nil))" "(time\\n     (do\\n       (doall a-few-tg-songs)\\n       nil))" "(take-sparsely 500 (gp-files-seq development-songs-directory))" "(doc for)" "(time\\n  (do\\n    (doall a-few-songs)\\n    nil))" "(time\\n     (do\\n       (doall a-few-songs)\\n       nil))" "(time\\n        (do\\n          (doall a-few-songs)\\n          nil))" "(time\\n  (doseq [song a-few-songs]\\n    nil))" "(time\\n  (doseq [song all-tg-songs]\\n    nil))" "(time\\n  (doseq [song all-songs]\\n    nil))" "(println \\"hello\\")" "(source defn)" "(doc fn)" "(source fn)" "(doc meta)" "(macroexpand (invalid-args->nil-fn [x y] (+ x y)))" "(macroexpand (invalid-args->nil-fn not-nil? [x y] (+ x y)))" "(macroexpand '(invalid-args->nil-fn not-nil? [x y] (+ x y)))" "(doc fn*)" "(doc macroexpand)" "(doc fn*)" "(macroexpand '(fn ^long coucou \\"returns 2 + x + y\\" [x y] (+ 2 x y)))" "(macroexpand '(fn ^long coucou [x y] (+ 2 x y)))" "(macroexpand '(fn ^java.util.ArrayList coucou \\"returns 2 + x + y\\" [x y] (java.util.ArrayList. (+ 2 x y))))" "(macroexpand '(fn ^java.util.ArrayList [x y] (java.util.ArrayList. (+ 2 x y))))" "(macroexpand-1 '(fn ^java.util.ArrayList coucou [x y] (java.util.ArrayList. (+ 2 x y))))" "(doc comp)" "(time (last a-few-tg-songs))" "(time\\n  (do\\n    (doall a-few-tg-songs)\\n    nil))" "(time\\n     (do\\n       (doall a-few-songs)\\n       nil))" "(source doall)" "(doc dorun)" "(time-sequence-traversal (a-few-songs))" "(time-sequence-traversal (all-songs))" "(time-sequence-traversal\\n  (all-songs))" "(time-sequence-traversal (all-tg-songs))" "(/ 325551.442021 60000)" "(time-sequence-traversal (fetch-all-songs))" "(/ 998345.305819 60000)" "(doc swap\!)" "(count (a-few-songs))" "(count (a-few-tg-songs))" "(pprint @problems-with-tg-songs)" "(count fetch-all-songs)" "(count (fetch-all-songs))" "(pprint @problems-with-nice-songs)" "(pprint @problems-with-tg-songs)" "(count @problems-with-tg-songs)" "(.printStackTrace (first (vals @problems-with-tg-songs)))" "(set\! *warn-on-reflection* true)" "(println \\"hello\\")" "\\"hello\\"" "(time-sequence-traversal (fetch-a-few-songs))" "(time-sequence-traversal (fetch-all-songs))" "(/ 557293.554203 60000)" "(rem 557 60)" "(pprint-song au-clair-de-la-lune)" "7/5" "(pprint-song smoke-water)" "(doc import)" "(doc reduce)" "(doc update-in)" "(di/pprint-song di/au-clair-de-la-lune)" "(doc merge)" "(doc ->)" "(read-NiceSong-from-resource \\"au_clair_de_la_lune.gp4\\" \:gp4 \\"Unknown\\")" "(pprint (read-NiceSong-from-resource \\"au_clair_de_la_lune.gp4\\" \:gp4 \\"Unknown\\"))" "(pprint (read-NiceSong-from-resource \\"au_clair_de_la_lune.gp4\\" \:\\"Unknown\\"))" "(pprint (read-NiceSong-from-resource \\"au_clair_de_la_lune.gp4\\" \\"Unknown\\"))" "chello" "(pprint chello)" "chello" "(total-time-per-pitch au-clair-de-la-lune)" "(pprint (total-time-per-pitch au-clair-de-la-lune))" "(doc reduce)" "(pprint (total-time-per-pitch au-clair-de-la-lune))" "(doc update-in)" "(get {3 5/2} 1 \\"Pas trouv\u00E9\\")" "(pprint (total-time-per-pitch au-clair-de-la-lune))" "(doc map)" "(pprint (total-time-per-pitch au-clair-de-la-lune))" "(pprint au-clair-de-la-lune)" "(pprint several-instruments)" "(pprint (total-time-per-pitch several-instruments))" "(pprint (total-time-per-pitch chello))" "(pprint (total-time-per-pitch rhapsody))" "(sum [1 2 3 4])" "(transform-map inc {\:a 1 \:b 2 \:c3})" "(transform-map inc {\:a 1 \:b 2 \:c 3})" "(pprint (normalize-distribution-map (total-time-per-pitch au-clair-de-la-lune)))" "(sum [1 2 4 5])" "(pprint (normalize-distribution-map (total-time-per-pitch au-clair-de-la-lune)))" "(sum (vals (pprint (normalize-distribution-map (total-time-per-pitch au-clair-de-la-lune)))))" "(sum (vals (normalize-distribution-map (total-time-per-pitch au-clair-de-la-lune))))" "(pitch-time-distribution chello)" "(pprint (pitch-time-distribution chello))" "(doc /)" "(/ 1 2 3)" "(pprint (pitch-time-distribution chello))" "(time-sequence-traversal (map pitch-time-distribution (fetch-songs)))" "(row-x 0)" "(row-x 7)" "(vec\\n  (map row-x\\n       (map (translate-12 7)\\n            (range 0 11))))" "(pprint (vec\\n     (map row-x\\n          (map (translate-12 7)\\n               (range 0 11)))))" "(map (translate-12 7)\\n                  (range 0 11))" "(range 0 11)" "(pprint (vec\\n        (map row-x\\n             (map (translate-12 7)\\n                  (range 0 12)))))" " (map (translate-12 7)\\n                     (range 0 12))" "(pprint (vec\\n           (map row-x\\n                (map (translate-12 7)\\n                     (range 0 12)))))" "(def ptd (pitch-time-distribution chello))" "(pprint ptd)" "(map println ptd)" "(pprint (to-scale-notes-distribution ptd))" "(mod -1 12)" "(pprint (to-scale-notes-distribution ptd))" "(pprint (to-literal-distribution (to-scale-notes-distribution ptd)))" "(doc reduce)" "(literal-note-of-scale-note scale-note)" "(pprint (to-literal-distribution (to-scale-notes-distribution ptd)))" "(pprint (to-scale-notes-distribution (pitch-time-distribution smoke-water)))" "(pprint (to-scale-notes-distribution (pitch-time-distribution au-clair-de-la-lune)))" "(empty-scale-notes-distribution)" "empty-scale-notes-distribution" "(pprint (to-scale-notes-distribution (pitch-time-distribution au-clair-de-la-lune)))" "(to-literal-distribution (to-scale-notes-distribution (pitch-time-distribution au-clair-de-la-lune)))" "(range 1 1000)" "(fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution chello)))" "(doc max-key)" "(to-scale-notes-distribution (pitch-time-distribution au-clair-de-la-lune))" "(fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution chello)))" "(to-scale-notes-distribution (pitch-time-distribution chello))" "(def snd (to-scale-notes-distribution (pitch-time-distribution chello)))" "snd" "(max-key snd snd)" "(doc max-key\\n     )" "(fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution chello)))" "(max-key inc 0 1 2 4)" "(doc apply)" "(fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution chello)))" "(to-scale-notes-distribution (pitch-time-distribution chello))" "(/ 0.1916243654822335 (- 0.1916243654822335 0.18401015228426396))" "(/ (- 0.1916243654822335 0.18401015228426396) 0.1916243654822335 )" "(def evidences\\n  (map \\n    (fn [song]\\n      (fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution song))))\\n    (fetch-songs)))" "evidences" "(wellformedness chello)" "(wellformedness au-clair-de-la-lune)" "(wellformedness smoke-water)" "(wellformedness rhapsody)" "(pprint (first (fetch-songs)))" "(pprint (wellformedness (first (fetch-songs))))" "(def evidences\\n     (map \\n       (fn [song]\\n         (fundamental-note-evidence (to-scale-notes-distribution (pitch-time-distribution song))))\\n       (fetch-songs)))" "evidences" "(def evidences\\n        (map \\n          wellformedness\\n          (fetch-songs)))" "evidences" "(def evidences\\n           (map \\n             wellformedness\\n             (fetch-songs)))" "evidences" "(def evidences\\n              (map \\n                wellformedness\\n                (fetch-songs)))" "evidences" "(def evidences\\n              (map \\n                wellformedness\\n                (fetch-songs)))" "evidences" "(def evidences\\n              (map \\n                wellformedness\\n                (fetch-songs)))" "evidences" "(def evidences\\n              (map \\n                wellformedness\\n                (fetch-songs)))" "evidences" "(pprint rhapsody)" "(pprint evidences)" "(doseq [song (fetch-all-songs)]\\n  (println (wellformedness song)))" "([1 2 3 4] 2)" "(assoc [0 1 2 3] 2 13)" "(vals [2 4 5 3])" "*warn-on-reflection*" "(set\! *warn-on-reflection* true)" "(sum (range 1 12))" "(time (sum (range 1 1000)))" "(sum (map \#(/ % 3) (range 1 30)))" "(sum (range 1 30))" "(/ (* 30 31) 2)" "(doc ->)" "(source ->)" "(doc  ->>)" "(doc <<)" "(doc str)" "(source spit)" "(source with-open)" "(doc condp)" "(class [1 2 3 4])" "(supers clojure.land.PersistentVector)" "(supers [1 2 3 4])" "(supers (class [1 2 4])\\n        )" "(supers clojure.lang.PersistentVector)" "(doc ->>)" "(doc extend)" "(doc clojure.lang.IPersistentVector)" "(class [1 2 3 4])" "(supers (class []))" "(class [])" "(class 45)" "(supers (class 45))" "(class 3/2)" "(supers clojure.lang.Ratio)" "(source +)" "(doc assoc)" "(source assoc)" "(value-at [1 5 3 2 8 4 6 5 7 8 5 1] 4)" "([1 5 3 2 8 4 6 5 7 8 5 1] 4)" "(value-at [1 5 3 2 8 4 6 5 7 8 5 1] 4)" "(supers clojure.lang.IPersistentVector)" "([1 5 3 2 8 4 6 5 7 8 5 1] (scale-note-of-pitch 20))" "(.value-at [1 5 3 2 8 4 6 5 7 8 5 1] 4)" "(value_at [1 5 3 2 8 4 6 5 7 8 5 1] 4)" "(valueAt [1 5 3 2 8 4 6 5 7 8 5 1] 4)" "(def that [1 5 3 2 8 4 6 5 7 8 5 1])" "(def pitch 20)" "(that (scale-note-of-pitch pitch))" "(valueAt that pitch)" "(class that)" "(class {1 3 2 5 4 8})" "(supers clojure.lang.PersistentArrayMap)" "(doc valueAt)" "(valueAt [1 2 3 4 5] 2)" "(coord [1 2 4] 1)" "(value-at [1 3 4 5] 2)" "(value-at [0 1 2 3 4 5 6 7 8 9 10 11] 5)" "(assoc (range 0 12) 4 5)" "(assoc (vec (range 0 12)) 4 5)" "(class (assoc (vec (range 0 12)) 4 5))" "(value-at {} 25)" "(assoc-pitch {} 25 4)" "(class (assoc-pitch {} 25 4))" "(supers clojure.lang.PersistentArrayMap)" "(set\! *warn-on-reflection* true)" "(pitch-time-distribution au-clair-de-la-lune)" "(pprint (pitch-time-distribution rhapsody))" "(pprint (to-scale-notes-distribution (pitch-time-distribution rhapsody)))" "(doc cond)" "(heiht 0)" "(heiht -20)" "(heiht 15)" "(-> chello pitch-time-distribution to-scale-notes-distribution pprint)" "(wellformedness chello)" "(doc mapv)" "(wellformedness chello)" "(wellformedness smoke-water)" "(doc reduce)" "(add-SNDs {1 1, 2 3, 5 7} {1 4, 7 8})" "(def some-snd (-> chello pitch-time-distribution to-scale-notes-distribution))" "some-snd" "(pprint (scale-SND 100 some-snd))" "(-SND some-snd some-snd)" "(doc assoc)" "(def acl (-> au-clair-de-la-lune total-time-per-pitch to-scale-notes-distribution normalize-distribution-map))" "acl" "(shift-SND acl 3)" "(max 3 nil)" "(doc max)" "(match-SNDs acl (shift-SND acl 3))" "(time (match-SNDs acl (shift-SND acl 3)))" "(time (dotimes [n 1000] (match-SNDs acl (shift-SND acl 3))))" "(time (dotimes [n 100000] (match-SNDs acl (shift-SND acl 3))))" "(/ 4964.101229 100000)" "({1 5} 3)" "(or 0 3)" "(or nil 0)" "(or 3 0)" "(def chello-dis (-> chello total-time-per-pitch))" "(pprint chello-dis)" "(to-scale-notes-distribution chello-dis)" "(image-distribution chello-dis scale-note-of-pitch)" "(to-scale-notes-distribution chello-dis)" "(image-distribution chello-dis scale-note-of-pitch)" "(to-scale-notes-distribution chello-dis)" "(image-distribution chello-dis scale-note-of-pitch)" "(set\! *warn-on-reflection* true)" "(doc keys)" "(doc vals)" "(doc partial)" "(-> chello pitch-time-distribution to-height-zone-distibution)" "(-> smoke-water pitch-time-distribution to-height-zone-distibution)" "(sum (vals (-> smoke-water pitch-time-distribution to-height-zone-distibution)))" "(doc take)" "(doc let)" "(let [(first second & rest) (list 1 2 3 4 5)]\\n  {\:first first\\n   \:second second\\n   \:rest rest})" "(let [[first second & rest] (list 1 2 3 4 5)]\\n     {\:first first\\n      \:second second\\n      \:rest rest})" "(def to-steps-seq (fn self [notesGroups-seq]\\n                       (let [first-2-ng (take 2 notesGroups-seq)]\\n                         (if (< (count first-2-ng) 2)\\n                           ()\\n                           (let [[{pos1 \:position} {pos2 \:position} & _] first-2-ng]\\n                             (lazy-seq\\n                               (cons (- pos2 pos1) (self (rest notesGroups-seq)))))))))" "(to-steps-seq (list {\:position 0}\\n                    {\:position 1}\\n                    {\:position 3/2}\\n                    {\:position 2}\\n                    {\:position 4}\\n                    {\:position 5/2}))" "(doc hash-map)" "(hash-map 1 23 4 56 7 89)" "(class (hash-map 1 23 4 56 7 89))" "(supers *1)" "(let [hm (java.util.HashMap. )]\\n  (doto hm\\n    (.put 1 23)\\n    (.put 2 34)\\n    (.put 3 45)\\n    (.put 2 56))\\n  hm)" "(def hm *1)" "(class hm)" "(assoc hm 7 89)" "(map hm)" "(map? hm)" "(keys hm)" "(vals hm)" "(zipmap (keys hm) (vals hm))" "(source zipmap)" "(count-to-bag '(1 5 2 4 6 1 2 5 7 8 5 4 1 2 3 5 2 1 6 5 4))" "(count-to-bag {})" "(doc +)" "(source +)" "(+distributions {\:a 5 \:b 8 \:c 45}\\n                {\:a 5 \:b 2 \:c 0}\\n                {\:d 1 \:b 8}\\n                {\:a 0 \:b 85 \:e 45}\\n                {})" "(map \:a (list {\:a 5 \:b 8 \:c 45}\\n                   {\:a 5 \:b 2 \:c 0}\\n                   {\:d 1 \:b 8}\\n                   {\:a 0 \:b 85 \:e 45}))" "(extract-rythm-steps-distribution au-clair-de-la-lune)" "(pprint au-clair-de-la-lune)" "(extract-rythm-steps-distribution chello)" "(let [{a-val \:a \:as mp} {\:a 1 \:b 2 \:c 3}]\\n  {\:a-val a-val\\n   \:mp mp})" "(maximal-point-info {\:a 5 \:b 2 \:c 5 \:d 3 \:e 3})" "(maximal-point-info {\:a 5 \:b 2 \:c 5 \:d 3 \:e 3 \:f 6 \:g 6 \:h -1})" " (maximal-point-info {\:a 5 \:b 2 \:c 5 \:d 3 \:e 3 \:f 6 \:g 6 \:h -1})" "(extract-rythm-steps-distribution au-clair-de-la-lune)" "(extract-rythm-steps-distribution chello)" "(extract-rythm-steps-distribution smoke-water)" "(pprint\\n  (extract-rythm-steps-distribution smoke-water))" "(doc extract-rythm-steps-distribution)" "(let [[first second & rest] (list 1 2 3 4)]\\n  {\:first first\\n   \:second second\\n   \:rest rest})" "(let [[first second & rest] (list 1 )]\\n     {\:first first\\n      \:second second\\n      \:rest rest})" "(extract-rythm-steps-distribution chello)" "(extract-rythm-steps-distribution smoke-water)" "(pprint (extract-rythm-steps-distribution chello))" "(pprint (extract-rythm-steps-distribution smoke-water))" "(sorted-set 1 3 5 4 8 2 4 6 7)" "(def sset *1)" "sset" "(class sset)" "(supers *1)" "(extract-rythm-steps-distribution au-clair-de-la-lune)" " (extract-rythm-steps-distribution au-clair-de-la-lune)" "(extract-rythm-steps-distribution smoke-water)" "(extract-rythm-steps-distribution chello)" "(supers WeightedPoint)" "(doc defmacro)" "(macroexpand '(def-distribution-binary-operator +distribs +))" "(macroexpand-1 '(def-distribution-binary-operator +distribs +))" "(pprint *1)" "(macroexpand-1 '(def-distribution-binary-operator +distribs +))" "(pprint *1)" "(time\\n  (dotimes [n 10]\\n    (extract-rythm-steps-distribution smoke-water)))" " (time\\n     (dotimes [n 10]\\n       (extract-rythm-steps-distribution smoke-water)))" "(class (keys {\:a 1 2 5 \\"g\\" \:b}))" "(supers *1)" "(.keySet (keys {\:a 1 2 5 \\"g\\" \:b}))" "(.keySet {\:a 1 2 5 \\"g\\" \:b})" "(class *1)" "(supers *1)" "(def map1 {\:a 1\\n          \:b 2\\n          \:c 3})" "(def map2 {\:b 2\\n           \:c 4\\n           \:d 6})" "(clojure.set/union (.keySet map1) (.keySet map2))" "(source merge)" "(source merge-with)" "(doc some)" "(doc identity)" "(time\\n        (dotimes [n 10]\\n          (extract-rythm-steps-distribution smoke-water)))" "(time\\n        (dotimes [n 1000]\\n          (extract-rythm-steps-distribution smoke-water)))" "(source dotimes)" "(extract-rythm-steps-distribution chello)" "(extract-rythm-steps-distribution au-clair-de-la-lune)" "(extract-rythm-steps-distribution smoke-water)" "(extract-rythm-steps-distribution chello)"]
eclipse.preferences.version=1
