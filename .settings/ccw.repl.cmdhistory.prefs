cmdhistory=["(clojure.core/use 'clojure.core)" "(import 'org.herac.tuxguitar.io.tg)" "(def settings (GTPSettings.))" "(class settings)" "(.getCharset settings)" "(. settings getCharset)" "(doc clojure.java.io/resource)" "(clojure.core/use 'clojure.core)" "(doc clojure.java.io/resource)" "(use 'clojure.repl)" "(doc clojure.java.io/resource)" "(use 'clojure.java.io/resource)" "(require '[clojure.java.io \:only resource])" "(resource \\"hello.txt\\")" "(require '[clojure.java.io \:as cio])" "(cio/resource \\"sample-file.txt\\")" "(def my-file-url (cio/resource \\"sample-file.txt\\"))" "my-file-url" "(def my-stream (java.io.FileInputStream. my-file-url))" "(def my-stream (. my-file-url openStream))" "(class my-stream)" "(. my-stream read)" "(. my-stream close)" "(defn open-my-stream [] (. my-file-url openStream))" "(def my-reader (BufferedReader. (InputStreamReader. (open-my-stream))))" "(class my-reader)" "(. my-reader readLine)" "(. my-reader close)" "(def my-tg-factory (TGFactory.))" "(. my-tg-factory newBeat)" "(def my-beat (. my-tg-factory newBeat))" "(class my-beat)" "(. my-stream close)" "(defn mygp3 []\\n  (resource-as-stream \\"sample-gp3.gp3\\"))" "(def myGP3stream (mygp3))" "(def gp3-is (GP3InputStream. settings))" "(class gp3-is)" "(. gp3-is (init my-tg-factory myGP3stream))" "(. gp3-is readSong)" "(. *1 getName)" "(. myGP3stream close)" "GP1InputStream." "GP4InputStream." "GP1InputStream" "(class GP1InputStream.)" "(class GP1InputStream)" "(def myclass java.util.HashMap)" "(myclass.)" "(def hm (new myclass))" "(GP1InputStream/GP1InputStream)" "(use 'clojure.tools.nrepl)" "(use 'clojure.repl)" "(doc new)" "(def my-class HashMap)" "(def my-class Object)" "(new myclass)" "(doc new)" "(new \\"Object\\")" "(new \\"java.lang.Object\\")" "(doc apply)" "(apply String '(\\"hello\\"))" "(doc with-open)" "(doc doto)" "(read-song\\n  (resource-as-stream \\"sample-gp3.gp3\\")\\n  \:gp3)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "(doc doto)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "*1" "(def my-song *2)" "my-song" "(def my-song (read-song\\n        (resource-as-stream \\"sample-gp3.gp3\\")\\n        \:gp3))" "my-song" "(. my-song toString)" "(. my-song getArtist)" "(. my-song getDate)" "(. my-song getMeasureHeaders)" "my-song" "(count (. my-song getMeasureHeaders))" "(doc read-song)" "(println \\"Hello\\")" "(doc extend-type)" "(doc deftype)" "(doc extend)" "(in-ns 'music-mining.tg-factory)" "(def song (Song.))" "(class song)" "song" "(doc proxy)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n           \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n              \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                 \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                    \:gp3)" "(time (dotimes [n 100]\\n        (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                             \:gp3)))" "(time (dotimes [n 1000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(time (dotimes [n 10000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(read-song \\n  (resource-as-stream \\"rhapsody.gp4\\") \:gp4)" "(time (dotimes [n 1000] (read-song \\n                             (resource-as-stream \\"rhapsody.gp4\\") \:gp4)))" "(def rhapsody \\n  (read-song (resource-as-stream \\"rhapsody.gp4\\") \:gp4))" "(.getName rhapsody)" "chello" "au-clair-de-la-lune" "(. getTracks au-clair-de-la-lune)" "(.getTracks au-clair-de-la-lune)" "(println (.getTracks au-clair-de-la-lune))" "au-clair-de-la-lune" "(print *e)" "au-clair-de-la-lune" "chello" "au-clair-de-la-lune" "chello" "rhapsody" "chello" "au-clair-de-la-lune" "drums" "several-instruments" "(def ptrack\\n  (.. drums getTracks next))" "(class ptrack)" "(percussion-track? ptrack)" "(def atrack\\n     (.. chello getTracks next))" "(percussion-track? atrack)" "(defn ^TGTrack first-track [^TGSong song]\\n  (.. song getTracks next))" "(percussion-track? (first-track au-clair-de-la-lune))" "(percussion-track? (first-track several-instruments))" "(percussion-track? (first-track rhapsody))" "au-clair-de-la-lune" "(doc iterator-seq)" "(- 3)" "(chello)" "chello" "(doc doseq)" "0/1" "1/2" "(class 0/1)" "(class 1/2)" "(+ 1/2 0)" "(.iterator [1 2 3 4])" "(iterator-seq (.iterator [1 2 3 4]))" "(doc swap\!)" "(doc doseq)" "au-clair-de-la-lune" "two-voices" "(doc conj)" "au-clair-de-la-lune" "(def atrack (. au-clair-de-la-lune (getTrack 0)))" "atrack" "(notes-of-track atrack)" "(def another-track (. chello (getTrack 0)))" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(doc defrecord)" "(doc vec)" "(notes-of-track atrack)" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(notes-of-song chello)" "(notes-of-song rhapsody)" "(notes-of-song au-clair-de-la-lune)" "(clojure.core/use 'clojure.repl)" "(find-doc pretty-print)" "(find-doc \\"pretty print\\")" "(notes-of-song several-instruments)" "(clojure.pprint \\"hello\\")" "(use 'clojure.pprint)" "(pprint (notes-of-song au-clair-de-la-lune))" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(pprint-song drums)" "(doc not)" "(notes-of-song drums)" "(pprint-song several-instruments)" "(pprint-song chello)" "(count (iterator-seq (. chello getTracks)))" "(pprint-song rhapsody)" "(time (let \\n        [res (notes-of-song rhapsody)]\\n        nil))" "(class 1/6)" "(pprint-song au-clair-de-la-lune)" "(pprint chello)" "(pprint-song chello)"]
eclipse.preferences.version=1
