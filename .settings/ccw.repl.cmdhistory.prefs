cmdhistory=["(clojure.core/use 'clojure.core)" "(import 'org.herac.tuxguitar.io.tg)" "(def settings (GTPSettings.))" "(class settings)" "(.getCharset settings)" "(. settings getCharset)" "(doc clojure.java.io/resource)" "(clojure.core/use 'clojure.core)" "(doc clojure.java.io/resource)" "(use 'clojure.repl)" "(doc clojure.java.io/resource)" "(use 'clojure.java.io/resource)" "(require '[clojure.java.io \:only resource])" "(resource \\"hello.txt\\")" "(require '[clojure.java.io \:as cio])" "(cio/resource \\"sample-file.txt\\")" "(def my-file-url (cio/resource \\"sample-file.txt\\"))" "my-file-url" "(def my-stream (java.io.FileInputStream. my-file-url))" "(def my-stream (. my-file-url openStream))" "(class my-stream)" "(. my-stream read)" "(. my-stream close)" "(defn open-my-stream [] (. my-file-url openStream))" "(def my-reader (BufferedReader. (InputStreamReader. (open-my-stream))))" "(class my-reader)" "(. my-reader readLine)" "(. my-reader close)" "(def my-tg-factory (TGFactory.))" "(. my-tg-factory newBeat)" "(def my-beat (. my-tg-factory newBeat))" "(class my-beat)" "(. my-stream close)" "(defn mygp3 []\\n  (resource-as-stream \\"sample-gp3.gp3\\"))" "(def myGP3stream (mygp3))" "(def gp3-is (GP3InputStream. settings))" "(class gp3-is)" "(. gp3-is (init my-tg-factory myGP3stream))" "(. gp3-is readSong)" "(. *1 getName)" "(. myGP3stream close)" "GP1InputStream." "GP4InputStream." "GP1InputStream" "(class GP1InputStream.)" "(class GP1InputStream)" "(def myclass java.util.HashMap)" "(myclass.)" "(def hm (new myclass))" "(GP1InputStream/GP1InputStream)" "(use 'clojure.tools.nrepl)" "(use 'clojure.repl)" "(doc new)" "(def my-class HashMap)" "(def my-class Object)" "(new myclass)" "(doc new)" "(new \\"Object\\")" "(new \\"java.lang.Object\\")" "(doc apply)" "(apply String '(\\"hello\\"))" "(doc with-open)" "(doc doto)" "(read-song\\n  (resource-as-stream \\"sample-gp3.gp3\\")\\n  \:gp3)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "(doc doto)" "(read-song\\n     (resource-as-stream \\"sample-gp3.gp3\\")\\n     \:gp3)" "(. *1 getName)" "*1" "(def my-song *2)" "my-song" "(def my-song (read-song\\n        (resource-as-stream \\"sample-gp3.gp3\\")\\n        \:gp3))" "my-song" "(. my-song toString)" "(. my-song getArtist)" "(. my-song getDate)" "(. my-song getMeasureHeaders)" "my-song" "(count (. my-song getMeasureHeaders))" "(doc read-song)" "(println \\"Hello\\")" "(doc extend-type)" "(doc deftype)" "(doc extend)" "(in-ns 'music-mining.tg-factory)" "(def song (Song.))" "(class song)" "song" "(doc proxy)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n           \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n              \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                 \:gp3)" "(read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                    \:gp3)" "(time (dotimes [n 100]\\n        (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                             \:gp3)))" "(time (dotimes [n 1000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(time (dotimes [n 10000]\\n           (read-song (resource-as-stream \\"sample-gp3.gp3\\")\\n                                \:gp3)))" "(read-song \\n  (resource-as-stream \\"rhapsody.gp4\\") \:gp4)" "(time (dotimes [n 1000] (read-song \\n                             (resource-as-stream \\"rhapsody.gp4\\") \:gp4)))" "(def rhapsody \\n  (read-song (resource-as-stream \\"rhapsody.gp4\\") \:gp4))" "(.getName rhapsody)" "chello" "au-clair-de-la-lune" "(. getTracks au-clair-de-la-lune)" "(.getTracks au-clair-de-la-lune)" "(println (.getTracks au-clair-de-la-lune))" "au-clair-de-la-lune" "(print *e)" "au-clair-de-la-lune" "chello" "au-clair-de-la-lune" "chello" "rhapsody" "chello" "au-clair-de-la-lune" "drums" "several-instruments" "(def ptrack\\n  (.. drums getTracks next))" "(class ptrack)" "(percussion-track? ptrack)" "(def atrack\\n     (.. chello getTracks next))" "(percussion-track? atrack)" "(defn ^TGTrack first-track [^TGSong song]\\n  (.. song getTracks next))" "(percussion-track? (first-track au-clair-de-la-lune))" "(percussion-track? (first-track several-instruments))" "(percussion-track? (first-track rhapsody))" "au-clair-de-la-lune" "(doc iterator-seq)" "(- 3)" "(chello)" "chello" "(doc doseq)" "0/1" "1/2" "(class 0/1)" "(class 1/2)" "(+ 1/2 0)" "(.iterator [1 2 3 4])" "(iterator-seq (.iterator [1 2 3 4]))" "(doc swap\!)" "(doc doseq)" "au-clair-de-la-lune" "two-voices" "(doc conj)" "au-clair-de-la-lune" "(def atrack (. au-clair-de-la-lune (getTrack 0)))" "atrack" "(notes-of-track atrack)" "(def another-track (. chello (getTrack 0)))" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(doc defrecord)" "(doc vec)" "(notes-of-track atrack)" "(notes-of-track another-track)" "(time (notes-of-track another-track))" "(notes-of-song chello)" "(notes-of-song rhapsody)" "(notes-of-song au-clair-de-la-lune)" "(clojure.core/use 'clojure.repl)" "(find-doc pretty-print)" "(find-doc \\"pretty print\\")" "(notes-of-song several-instruments)" "(clojure.pprint \\"hello\\")" "(use 'clojure.pprint)" "(pprint (notes-of-song au-clair-de-la-lune))" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(pprint-song drums)" "(doc not)" "(notes-of-song drums)" "(pprint-song several-instruments)" "(pprint-song chello)" "(count (iterator-seq (. chello getTracks)))" "(pprint-song rhapsody)" "(time (let \\n        [res (notes-of-song rhapsody)]\\n        nil))" "(class 1/6)" "(pprint-song au-clair-de-la-lune)" "(pprint chello)" "(pprint-song chello)" "(doc comp)" "(pprint-song rhapsody)" "(doc pprint)" "*out*" "(class *out*)" "(source doc)" "(pprint-song au-clair-de-la-lune)" "(pprint-song rhapsody)" "(pprint-song chello)" "(pprint-song rhapsody)" "bend" "(def track (.. bend getTracks next))" "track" "(def measure (.. track getMeasures next))" "measure" "(def note (.. measure (getBeats 0) (getVoice 0) (getNotes 0)))" "(def note (.. measure (getBeats) (get 0) (getVoice 0) (getNotes) (get 0)))" "note" "(def effect (. note getEffect))" "effect" "(def bend-effect (. effect getBend))" "bend-effect" "(. bend-effect getPoints)" "(. (last (. bend-effect getPoints)) getValue)" "(. (first (. bend-effect getPoints)) getValue)" "(. ((. bend-effect getPoints) 1) getValue)" "(doc nth)" "(. (nth (. bend-effect getPoints) 1) getValue)" "(. (nth (. bend-effect getPoints) 0) getValue)" "(if nil true false)" "(pprint-song au-clair-de-la-lune)" "(doc spit)" "(pprint-song smoke-water)" "smoke-water" "(pprint-song smoke-water)" "(pprint-song au-clair-de-la-lune)" "(pprint-song bend)" "(pprint-song au-clair-de-la-lune)" "(au-clair-de-la-lune)" "au-clair-de-la-lune" "(pprint-song au-clair-de-la-lune)" "(doc or)" "(or nil 3)" "(or 5 nil)" "(or 2 3)" "(pprint-song au-clair-de-la-lune)" "(pprint-song bend)" "bend" "(pprint-song bend)" "(find-doc floor)" "(find-doc \\"floor\\")" "(doc int)" "(doc %)" "(pprint-song au-clair-de-la-lune)" "(int 2/3)" "(int 7/4)" "(doc quot)" "(quot 7 5)" "(pprint-song bend)" "(pprint-song rhapsody)" "(pprint-song au-clair-de-la-lune)" "(doseq pprint-song all-samples)" "(map pprint-song all-samples)" "(doc map)" "(pprint-song chello)" "(pprint-song rhapsody)" "(pprint-song au-clair-de-la-lune)" "(pprint-song drums)" "(pprint-song several-instruments)" "(pprint-song two-voices)" "(pprint-song smoke-water)" "*e" "(. *e getTrace)" "(. *e printStackTrace)" "(. *e getStackTrace)" "smoke-water" "(pprint smoke-water)" "(pprint-song smoke-water)" "(notes-of-song smoke-water)" "(quot 255 4)" "(notes-of-track (.. smoke-water (getTracks) (next)))" "(notes-of-track (.. smoke-water (getTracks) (next) (next)))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0)))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 1))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 2))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 3))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 1)))" "(pprint (notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0)))" "(quot 3 4)" "(quot 255 4)" "(rem 255 4)" "(doc let)" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(quot 815/2 4)" "(rem 815/2 8)" "(rem 815/2 4)" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(quot 512/2 4)" "(alert-null 3 \\"should not show\\")" "(alert nil \\"should show\\")" "(alert-null nil \\"should show\\")" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(notes-of-track (nth (. smoke-water getTracks) 0))" "(notes-of-track (nth (iterator-seq (. smoke-water getTracks)) 0))" "(def track (nth (iterator-seq (. smoke-water getTracks)) 0))" "track" "(def measure (nth (. track getMeasures) 64))" "(def measure (nth (iterator-seq (. track getMeasures)) 64))" "measure" "(def beat (nth (. measure getBeats) 4))" "beat" "(def note (.. beat (getVoice 0) (getNote 0)))" "note" "(. note getEffect)" "(.. note getEffect getBend)" "(.. note getEffect getTremoloBar)" "(.. note getEffect getTremoloBar getPoints)" "(.. note getEffect getTremoloBar getPoints (get 2))" " (.. note getEffect getTremoloBar getPoints (get 2) getValue)" "(quot 512/2 4)" "(rem 512/2 4)" "(rem 515/2 4)" "note" "(def tg-string (.. track (getString 3)))" "tg-string" "(pitch-of-fretted-note tg-string note)" "(pprint-song smoke-water)" "(pprint-song rhapsody)"]
eclipse.preferences.version=1
